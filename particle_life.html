<html>
  <head>
    <title>Particle Life JS JS</title>
  </head>

  <style>
  body {margin: 0;}
  canvas {width: 100%; height: 100%;}
  </style>

  <body>
	<link rel="shortcut icon" href="#">

   
    <style>
    			body {
    				font-family: Monospace;
    				background-color: #000000;
    				color: #fff;
    				margin: 0px;
    				overflow: hidden;
    			}
    			#step_counter {
    				position: absolute;
    				top: 9px;
    				width: 100%;
    				text-align: center;
    			}
          #particle_cam_label {
            position: absolute;
            bottom: 30px;
            left: 30px;
            width: 100%;
            text-align: left;
            font-size: 50px;
            color: #fff;
          }
    </style>

    <div id="step_counter">
      <p>Step: 0 <br>
        Particles: 0
      </p>
    </div>
    
    <div id="particle_cam_label">
      <p> </p>
    </div>

		<script type="importmap">
			{
				"imports": {
					"three": "./build/three.module.js",
          "three-noise": "./build/three-noise.module.js"
				}
			}
		</script>

    <script type="x-shader/x-vertex" id="vertex_shader_simple">
      varying vec2 vUv;
      
      void main() {
        vUv = uv;
        vec4 ViewPosition = modelViewMatrix * vec4(position, 1.0);
        gl_Position = projectionMatrix * ViewPosition;
      }
    </script>

    <script type="x-shader/x-fragment" id="fragment_shader_simple">
      uniform vec3 pCol;
      uniform float neighbour_count;
      uniform sampler2D tTexture;

      varying vec2 vUv;

      void main() {
        vec3 c = vec3(1, 1, 1) - pCol;
        //gl_FragColor = vec4(pCol + c * neighbour_count, 1.0);
        gl_FragColor = texture2D(tTexture, vUv) + vec4(pCol + c * neighbour_count, 1.0);
      }
    </script>
		
	<script type="module">

    
	import * as THREE from 'three';
	import { OrbitControls } from './build/controls/OrbitControls.js';
  import { GUI } from './build/gui/dat.gui.module.js';
  import { TrailRenderer } from './build/TrailRenderer.js';
  import { TextureLoader } from './node_modules/three/src/loaders/TextureLoader.js';
  import { AudioLoader } from './node_modules/three/src/loaders/AudioLoader.js';
  import { AudioListener } from './node_modules/three/src/audio/AudioListener.js';
  import { Audio } from './node_modules/three/src/audio/Audio.js';
  
    
    // EXAMPLE - GREEN ATTRACTED TO RED: rules.push(new Rule('Green', 'Red', 1.0));
    function Rule (ca, cb, f){
        this.colourA = ca;
        this.colourB = cb;
        this.force = f; // positive values create attraction force
    }

    function Colour (col, cName){
      this.colour = col;
      this.name = cName;
    }

    // PALETTES
    const backgrounds = [ new THREE.Color("#0f0f0f"), new THREE.Color("#f0f6e8"), new THREE.Color("#2f2442"),
                          new THREE.Color("#95d9bc"), new THREE.Color("#e6ceac"), new THREE.Color("#130208"),
                          new THREE.Color("#a597a1"), new THREE.Color("#000924")
    ];
    // BASE
    const palette1 = [
      new Colour(new THREE.Color(1,0,0), 'Red'), new Colour(new THREE.Color(0,0,1), 'Blue'), new Colour(new THREE.Color(0,1,0), 'Green'),
      new Colour(new THREE.Color(1,1,0), 'Yellow'), new Colour(new THREE.Color(0.3,0,1), 'Purple'), new Colour(new THREE.Color(1,0.5,0), 'Orange')];
    // PASTELS https://lospec.com/palette-list/fairydust-8
    const palette2 = [
      new Colour(new THREE.Color("#c45d9f"), 'Red'), new Colour(new THREE.Color("#6461c2"), 'Blue'), new Colour(new THREE.Color("#2ba9b4"), 'Green'),
      new Colour(new THREE.Color("#f0dab1"), 'Yellow'), new Colour(new THREE.Color("#634b7d"), 'Purple'), new Colour(new THREE.Color("#e39aac"), 'Orange')];
    // PINKS https://lospec.com/palette-list/krea-8
    const palette3 = [
      new Colour(new THREE.Color("#f3c4d8"), 'Pink1'), new Colour(new THREE.Color("#e18dcb"), 'Pink2'), new Colour(new THREE.Color("#c760bc"), 'Pink3'),
      new Colour(new THREE.Color("#b44db7"), 'Pink4'), new Colour(new THREE.Color("#783a8d"), 'Purple1'), new Colour(new THREE.Color("#603b7f"), 'Purple2')];
    // GREENS https://lospec.com/palette-list/grenade-8
    const palette4 = [
      new Colour(new THREE.Color("#6bad92"), 'Green1'), new Colour(new THREE.Color("#377a5d"), 'Green2'), new Colour(new THREE.Color("#2b5744"), 'Green3'),
      new Colour(new THREE.Color("#263d32"), 'Green4'), new Colour(new THREE.Color("#1b2621"), 'Green5'), new Colour(new THREE.Color("#131a17"), 'Green6')];
    // Parchment https://lospec.com/palette-list/justparchment8 
    const palette5 = [
      new Colour(new THREE.Color("#292418"), 'Paper1'), new Colour(new THREE.Color("#bda583"), 'Paper2'), new Colour(new THREE.Color("#a48d6a"), 'Paper3'),
      new Colour(new THREE.Color("#8b7d62"), 'Paper4'), new Colour(new THREE.Color("#73654a"), 'Paper5'), new Colour(new THREE.Color("#524839"), 'Paper6')];
    // Rose https://lospec.com/palette-list/midnight-ablaze
    const palette6 = [
      new Colour(new THREE.Color("#d53c6a"), 'Rose2'), new Colour(new THREE.Color("#460e2b"), 'Rose4'), new Colour(new THREE.Color("#1f0510"), 'Rose6'),
      new Colour(new THREE.Color("#ff8274"), 'Rose1'), new Colour(new THREE.Color("#7c183c"), 'Rose3'), new Colour(new THREE.Color("#31051e"), 'Rose5')];
    // Clouds https://lospec.com/palette-list/cl8uds
    const palette7 = [
      new Colour(new THREE.Color("#fcb08c"), 'Orange1'), new Colour(new THREE.Color("#a5b7d4"), 'Blue1'), new Colour(new THREE.Color("#d6938a"), 'Orange3'),
      new Colour(new THREE.Color("#9aabc9"), 'Blue2'), new Colour(new THREE.Color("#ef9d7f"), 'Orange2'), new Colour(new THREE.Color("#8fa0bf"), 'Blue3')];
    // Aquaverse https://lospec.com/palette-list/aquaverse
    const palette8 = [
      new Colour(new THREE.Color("#093659"), 'Blue1'), new Colour(new THREE.Color("#46cfb3"), 'Aqua1'), new Colour(new THREE.Color("#145d87"), 'Blue2'),
      new Colour(new THREE.Color("#73f0c6"), 'Aqua2'), new Colour(new THREE.Color("#228399"), 'Blue3'), new Colour(new THREE.Color("#abffd1"), 'Aqua3')];
    
    const palettes = [palette1, palette2, palette3, palette4, palette5, palette6, palette7, palette8];
    
    // Setting up Colours
    var pColours = [];

    // ---------------------------- ---------------- ---------------------------- //
    // ---------------------------- SIMULATION SPECS ---------------------------- //
    // ---------------------------- ---------------- ---------------------------- //
    // Simulation Parameters
    var max_force_dist = 10;
    var inflection_distance = 0.2;
    var delta_time = 0.01;
    var force_factor = 7;
    var is_paused = true;
    var simulation_radius = new THREE.Vector3(100, 0, 100);
    var particles_scale = 1.0;
    var colour_count = 4; // 1-6

    // Space Partitioning Grid
    var grid_scale = Math.min(Math.max(Math.floor(simulation_radius.x / (2 * max_force_dist)), 3), 6); // divides space by this number
    var visualise_grid = false;
    var grid = [];
    const partitioning_toggle = false;


    // Shader params
    var shader_enabled = false; // cell-finder shader -> grays out lonely particles, vibrant colours for cells
    var cell_finder_size = 200;
    var palette_num = 0; // 0-7
    var has_trails = false;
    var trail_length = 20;

    var music_vol = 0.3;

    var part_cam_enabled = false;
    var particle_cam_focus = 0;
    const c0_names = ['Mario', 'Charmander', 'p-42', 'Lilo', 'Rand', 'Zagreus', 'Streaky-Bacon', 'Luffy', 'PB', 'Lorraine', 'Hornet', 'Azula', 'Zuko']; // Red
    const c1_names = ['Squirtle', 'Sert', 'x-626', 'Stitch', 'Finn', 'Ranni', 'Morraine', 'Jinx', 'Bo', 'The Knight', 'Azure', 'Sokka', 'Katara']; // Blue
    const c2_names = ['Luigi', 'Bulbasaur', 'g-360', 'Link', 'Bilbo', 'Ekko', 'Zac', 'Zoro', 'Shrek', 'Snake', 'Moss']; // Green
    const c3_names = ['Pika', 'Mega-Beedrill', 'p-69000x', 'Jake', 'Yellow-Pikmin-13', 'Mel', 'Ocelot', 'Memph', 'Aang', 'Oatchi']; // Yellow
    const c4_names = ['Ganon', 'Waluigi', 'p-5876', 'Frodo', 'Milly', 'Preminger', 'LSP', 'Discord-Kitten', 'The Mindflayer']; // Purple
    const c5_names = ['Garfield', 'Cubert', 'p-18', 'Cheeto', 'Dorito', 'Nami', 'Favourite-Fearless-Hero', 'The RADIANCE']; // Orange

    //pColours = palettes[palette_num];
    for (let i = 0; i < colour_count; i++) {
      pColours.push(palettes[palette_num][i]);
    }

    const steps_till_update = 10;
    var current_step = 0;

    // Simulation fixed properties
    const friction_half_life = 0.040;
    const particle_count = 1700; // 1000 - 2000
    var friction_factor = Math.pow(0.5, delta_time/friction_half_life);
    var is_wire_framed = false;

    // Other vars
    var matrix = get_random_matrix(colour_count);
    var particles = [];
    var mid_point = new THREE.Vector3(simulation_radius.x / 2, simulation_radius.y / 2, simulation_radius.z / 2);
    
    document.getElementById('step_counter').textContent = "Particles: " + particle_count + " Step: " + current_step;
    // ---------------------------- ---------------- ---------------------------- //
    // ---------------------------- ---------------- ---------------------------- //


    // create scene
    var scene = new THREE.Scene( );
    var ratio = window.innerWidth/window.innerHeight;

    // perspective camera
    const camera = new THREE.PerspectiveCamera(60,ratio,1,1000);
    scene.add(camera);

    //create the webgl renderer
    var renderer = new THREE.WebGLRenderer( );
    renderer.setClearColor(backgrounds[palette_num]);

    //set the size of the rendering window
    renderer.setSize(window.innerWidth,window.innerHeight);

    //add the renderer to the current document
    document.body.appendChild(renderer.domElement );

    //create the mesh of a cube
    var geometry_cube = new THREE.BoxGeometry(1,1,1);
    
    //set the camera position
    camera.position.x = simulation_radius.x / 2;
    camera.position.y = 100;
    camera.position.z = simulation_radius.z / 2;

    //camera.lookAt(new THREE.Vector3(simulation_radius.x / 2, 0, simulation_radius.z / 2));
    camera.lookAt(new THREE.Vector3(0, -10, 0));
    renderer.render(scene, camera);
    
    // Drawing the cube area of the simulation
    var simulation_mat = new THREE.MeshBasicMaterial();
    //simulation_mat.color = new THREE.Color(1, 1, 1);
    simulation_mat.transparent = true;
    simulation_mat.opacity = 0.05;
    simulation_mat.wireframe = true;

    var sim_cube = new THREE.Mesh(geometry_cube,simulation_mat);
    sim_cube.scale.x = simulation_radius.x;
    sim_cube.scale.y = simulation_radius.y;
    sim_cube.scale.z = simulation_radius.z;

    sim_cube.position.x = simulation_radius.x / 2;
    sim_cube.position.y = simulation_radius.y / 2;
    sim_cube.position.z = simulation_radius.z / 2;

    scene.add(sim_cube);

    // ---------------------------- ---------------- ---------------------------- //
    // ---------------------------- ---------------- ---------------------------- //

    

    // ---------------------------- ---------------- ---------------------------- //
    // ---------------------------- ---------------- ---------------------------- //

    // Particle Mesh
    var geometry_icosahedron = new THREE.IcosahedronGeometry(1, 0);
    const textureLoader = new THREE.TextureLoader();

    // Trail setup
    const trailHeadGeometry = [];
    trailHeadGeometry.push( 
      new THREE.Vector3( -1.5, 0.0, 0.0 ), 
      new THREE.Vector3( 0.0, 0.0, 0.0 ), 
      new THREE.Vector3( 1.5, 0.0, 0.0 ) 
    );
    

    // MUSIC SETUP //
    const listener = new THREE.AudioListener();
    camera.add(listener);

    // create a global audio source
    const musicBot = new THREE.Audio( listener );

    // load a sound and set it as the Audio object's buffer
    const audioLoader = new THREE.AudioLoader();


    function CreateScene()
    {
      for (var i = 0; i < particle_count; i++) {
        // Grab colour
        var c = Math.floor((i / particle_count) * pColours.length);

        var material_particle = new THREE.ShaderMaterial( {
          vertexShader: document.getElementById('vertex_shader_simple').textContent,
          fragmentShader: document.getElementById('fragment_shader_simple').textContent,
          uniforms: {
            pCol: {value: pColours[c].colour},
            neighbour_count: {value: 0},
            //tTexture: { type: 't', value: textureLoader.load('./textures/triangle_texture.jpeg')}
            //tTexture: { type: 't', value: textureLoader.load('./textures/swirl_pattern.jpeg')}
            //tTexture: { type: 't', value: textureLoader.load('./textures/drops_texture.jpeg')}
            //tTexture: { type: 't', value: textureLoader.load('./textures/marble_texture.jpeg')}
          },
        });

        material_particle.transparent = true;

        //then set the renderer to wireframe
        material_particle.wireframe = is_wire_framed;

        //all the transformation are 4x4 matrices as
        var rot2 = new THREE.Matrix4();
        var sca = new THREE.Matrix4();
        var rot = new THREE.Matrix4();
        var tra = new THREE.Matrix4();
        var combined = new THREE.Matrix4();

        combined.multiply(tra);
        combined.multiply(sca);

        var particle = new THREE.Mesh(geometry_icosahedron,material_particle);

        // Setting colours
        material_particle.color =  pColours[c].colour;
        particle.userData.pColour = pColours[c].name;
        particle.userData.pColourNum = c;

        particle.applyMatrix4(combined);

        particle.position.x = mid_point.x + (Math.random() - 0.5) * simulation_radius.x;
        particle.position.y = mid_point.y + (Math.random() - 0.5) * simulation_radius.y;
        particle.position.z = mid_point.z + (Math.random() - 0.5) * simulation_radius.z;
        
        particle.userData.vx = 0;//Math.random();
        particle.userData.vy = 0;//Math.random();
        particle.userData.vz = 0;//Math.random();

        if (!partitioning_toggle) {
          particle.userData.neighbours = [];
        }

        particle.scale.x = particles_scale;
        particle.scale.y = particles_scale;
        particle.scale.z = particles_scale;

        // Trails
        // create the trail renderer object
        const trail = new TrailRenderer( scene, false );

        // set how often a new trail node will be added and existing nodes will be updated
        trail.setAdvanceFrequency(100);

        // create material for the trail renderer
        const trailMaterial = TrailRenderer.createBaseMaterial();	
        
        trailMaterial.uniforms.headColor.value = new THREE.Vector4(pColours[c].colour.r, pColours[c].colour.g, pColours[c].colour.b, 1.0);
        trailMaterial.uniforms.tailColor.value = new THREE.Vector4(pColours[c].colour.r, pColours[c].colour.g, pColours[c].colour.b, 0.1);

        // specify length of trail
        const trailLength = trail_length;

        // initialize the trail
        trail.initialize( trailMaterial, trailLength, false, 0, trailHeadGeometry, particle );

        // activate the trail
        if (has_trails) {
          trail.activate();
        }
        

        particle.userData.trail = trail;
        // ------------- //

        particles.push(particle);
        scene.add(particles[i]);
      }
    }

    
 
  CreateScene();
  if (!partitioning_toggle) { update_neighbours; }
  else { generate_grid(); }
  
  
  //////////////
	// CONTROLS //
	//////////////

	// move mouse and: left   click to rotate,
	//                 middle click to zoom,
	//                 right  click to pan
  // add the new control and link to the current camera to transform its position

  var controls = new OrbitControls( camera, renderer.domElement );
  controls.target = mid_point;

  function get_force(distance, interaction_force) {
    
    if (distance < inflection_distance) {
      return distance / inflection_distance - 1;
    }
    else if (inflection_distance < distance && distance < 1) {
      return interaction_force * (1 - Math.abs(2 * distance - 1 - inflection_distance) / (1 - inflection_distance));
    }
    else {
      return 0;
    }
  }

  function get_random_matrix(size) {
    const rows = [];
    for (let i = 0; i < size; i++) {
      const row = [];
      for (let j = 0; j < size; j++) {
        row.push(new Rule(pColours[i], pColours[j], Math.random() * 2 - 1));
      }
      rows.push(row);
    }
    return rows;
  }

  function update_neighbours() {
    for (var i = 0; i < particle_count; i++) {
      const partA = particles[i];
      var new_neighbours = [];
      for (var j = 0; j < particle_count; j++) {
        if (j === i) continue;
        const partB = particles[j];

        const distX = partB.position.x - partA.position.x;
        const distY = partB.position.y - partA.position.y;
        const distZ = partB.position.z - partA.position.z;
        const dist = Math.sqrt(distX * distX + distY * distY + distZ * distZ);
        

        // Check particle pair is within min and max distances
        if (dist < max_force_dist) {
          new_neighbours.push(partB);
        }
      }
      partA.userData.neighbours = new_neighbours;
      if (shader_enabled) {
        partA.material.uniforms.neighbour_count.value = Math.min(1 - new_neighbours.length / cell_finder_size, 1.0);//Math.min(1 - partA.userData.neighbours.length / 200, 1.0);
      }
    }
  }

  function simulation_step () {
    // Loop over all particles
    for (var i = 0; i < particle_count; i++) {
      // Setup force variables
      let totalForceX = 0;
      let totalForceY = 0;
      let totalForceZ = 0;

      const partA = particles[i];
      // Loop over each pair of neighbouring particles
      for (var j = 0; j < partA.userData.neighbours.length; j++) {
        if (j === i) continue;
        const partB = partA.userData.neighbours[j];

        // Calculate distances
        const distX = partB.position.x - partA.position.x;
        const distY = partB.position.y - partA.position.y;
        const distZ = partB.position.z - partA.position.z;
        const dist = Math.sqrt(distX * distX + distY * distY + distZ * distZ);

        // Check particle pair is within min and max distances
        if (dist > 0 && dist < max_force_dist) {
          const force = get_force(dist / max_force_dist, matrix[partA.userData.pColourNum][partB.userData.pColourNum].force);
          totalForceX += distX / dist * force;
          totalForceY += distY / dist * force;
          totalForceZ += distZ / dist * force;
        }
      }

      // Scale by max
      totalForceX *= max_force_dist * force_factor;
      totalForceY *= max_force_dist * force_factor;
      totalForceZ *= max_force_dist * force_factor;

      // Apply Friction to velocity
      partA.userData.vx *= friction_factor;
      partA.userData.vy *= friction_factor;
      partA.userData.vz *= friction_factor;

      // Add force to particle velocity
      partA.userData.vx += totalForceX * delta_time;
      partA.userData.vy += totalForceY * delta_time;
      partA.userData.vz += totalForceZ * delta_time;
      
    }
    
    for (var i = 0; i < particle_count; i++) {
      // Update positions
      particles[i].position.x += particles[i].userData.vx * delta_time;
      particles[i].position.y += particles[i].userData.vy * delta_time;
      particles[i].position.z += particles[i].userData.vz * delta_time;

      // Screen wrapping
      if (particles[i].position.x > simulation_radius.x) { particles[i].position.x = 1; particles[i].userData.trail.reset(); }
      else if (particles[i].position.x < 0) { particles[i].position.x = simulation_radius.x -1; particles[i].userData.trail.reset(); }

      if (particles[i].position.y > simulation_radius.y) { particles[i].position.y = 1; particles[i].userData.trail.reset(); }
      else if (particles[i].position.y < 0) { particles[i].position.y = simulation_radius.y -1; particles[i].userData.trail.reset(); }

      if (particles[i].position.z > simulation_radius.z) { particles[i].position.z = 1; particles[i].userData.trail.reset(); }
      else if (particles[i].position.z < 0) { particles[i].position.z = simulation_radius.z -1; particles[i].userData.trail.reset(); }

      // Update trails
      particles[i].userData.trail.update();
    }
  }

  function partitioned_step() {
    update_partitions();

    // loop through each particle
    for (var i = 0; i < particle_count; i++) {
      let totalForceX = 0;
      let totalForceY = 0;
      let totalForceZ = 0;

      const partA = particles[i];

      // get partition
      const grid_size = simulation_radius.x / grid_scale;
      const partitionRow = Math.floor(particles[i].position.z / grid_size);
      const partitionColumn = Math.floor(particles[i].position.x / grid_size);
      const partition = partitions[partitionRow * grid_scale  + partitionColumn];

      // loop over all particles in same partition
      for (var j = 0; j < partition.length; j++) {
        const partB = partition[j];
        if (partA === partB) continue;

        // Calculate distances
        const distX = partB.position.x - partA.position.x;
        const distY = partB.position.y - partA.position.y;
        const distZ = partB.position.z - partA.position.z;
        const dist = Math.sqrt(distX * distX + distY * distY + distZ * distZ);

        // Check particle pair is within min and max distances
        if (dist > 0 && dist < max_force_dist) {
          const force = get_force(dist / max_force_dist, matrix[partA.userData.pColourNum][partB.userData.pColourNum].force);
          totalForceX += distX / dist * force;
          totalForceY += distY / dist * force;
          totalForceZ += distZ / dist * force;
        }
      }

      // Scale by max
      totalForceX *= max_force_dist * force_factor;
      totalForceY *= max_force_dist * force_factor;
      totalForceZ *= max_force_dist * force_factor;

      // Apply Friction to velocity
      partA.userData.vx *= friction_factor;
      partA.userData.vy *= friction_factor;
      partA.userData.vz *= friction_factor;

      // Add force to particle velocity
      partA.userData.vx += totalForceX * delta_time;
      partA.userData.vy += totalForceY * delta_time;
      partA.userData.vz += totalForceZ * delta_time;
    }

    // Finally loop over particles and move them
    for (var i = 0; i < particle_count; i++) {
      // Update positions
      particles[i].position.x += particles[i].userData.vx * delta_time;
      particles[i].position.y += particles[i].userData.vy * delta_time;
      particles[i].position.z += particles[i].userData.vz * delta_time;

      // Screen wrapping
      if (particles[i].position.x > simulation_radius.x) { particles[i].position.x = 1; particles[i].userData.trail.reset(); }
      else if (particles[i].position.x < 0) { particles[i].position.x = simulation_radius.x -1; particles[i].userData.trail.reset(); }

      if (particles[i].position.y > simulation_radius.y) { particles[i].position.y = 1; particles[i].userData.trail.reset(); }
      else if (particles[i].position.y < 0) { particles[i].position.y = simulation_radius.y -1; particles[i].userData.trail.reset(); }

      if (particles[i].position.z > simulation_radius.z) { particles[i].position.z = 1; particles[i].userData.trail.reset(); }
      else if (particles[i].position.z < 0) { particles[i].position.z = simulation_radius.z -1; particles[i].userData.trail.reset(); }

      // Update trails
      particles[i].userData.trail.update();
    }
  }

  var partitions = [];
  function update_partitions() {
    partitions = [];
    for (var i = 0; i < grid.length; i++) {
      const partition = [];
      partitions.push(partition);
    }

    const grid_size = simulation_radius.x / grid_scale;
    // Put each particle into a partition based on position
    for (var i = 0; i < particle_count; i++) {
      const partitionRow = Math.floor(particles[i].position.z / grid_size);
      const partitionColumn = Math.floor(particles[i].position.x / grid_size);
      
      partitions[partitionRow * grid_scale + partitionColumn].push(particles[i]);
    }
  }

  function delete_grid() {
    while (grid.length > 0) {
      scene.remove(grid.pop());
    }
  }

  function generate_grid() {
    // Empty existing grid
    delete_grid()

    // Side length of each grid segment
    const grid_size = simulation_radius.x / grid_scale;
    //const grid_colour_1 = new THREE.Color(1, 1, 1);

    if (visualise_grid) {
      const grid_cube_geometry = new THREE.BoxGeometry(grid_size, simulation_radius.y ,grid_size);
      // Grid on the x
      for (var i = 0; i < grid_scale; i++) {
        // Grid on the z
        for (var j = 0; j < grid_scale; j++) {
          
          // // 3D GRID
          // if (simulation_radius.z > grid_size) {
          //   // Grid on the y
          //   for (var w = 0; w < grid_scale; w++) {

          //   }
          // }
          
          const grid_mat = new THREE.MeshBasicMaterial();
    
          grid_mat.transparent = true;
          grid_mat.opacity = 0.25;
          grid_mat.wireframe = false;
          //grid_mat.color = backgrounds[palette_num];

          const c = backgrounds[palette_num];
          if (i % 2 == 1 ^ j % 2 == 0) { grid_mat.color = c; }
          else { grid_mat.color = new THREE.Color(1 - c.r, 1 - c.g, 1 - c.b); }

          const new_grid_cube = new THREE.Mesh(grid_cube_geometry, grid_mat);
          
          // Setting positions
          new_grid_cube.position.x = (grid_size / 2) + (grid_size) * i;
          new_grid_cube.position.y = simulation_radius.y / 2;
          new_grid_cube.position.z = (grid_size / 2) + (grid_size) * j;
          
          grid.push(new_grid_cube);
          scene.add(new_grid_cube);

          
        }
      }
    }
  }

  function music_check() {
    if (is_paused) {
      musicBot.pause();
      return;
    }

    if (musicBot.isPlaying) { musicBot.stop(); }
    audioLoader.load( './music/loop' + colour_count + '.wav', function( buffer ) {
      musicBot.setBuffer( buffer );
      musicBot.setLoop( true );
      musicBot.setVolume(music_vol);
      musicBot.play();
    });
    
  }

  var Animate = function() {
    if (!partitioning_toggle) {
      if (current_step % steps_till_update == 0) {
        update_neighbours();
      }
      simulation_step();
    }
    else {
      partitioned_step();
    }
    current_step++;
    document.getElementById('step_counter').textContent = "Particles: " + particle_count + " Step: " + current_step;
  }

  // final update loop
  var MyUpdateLoop = function ( )
  {
    
    controls.update();

    // call the render with the scene and the camera
    renderer.render(scene,camera);

    // finally perform a recursive call to update again
    // this must be called because the mouse changes the camera position
    
    requestAnimationFrame(MyUpdateLoop);
    if (!is_paused) { Animate(); }
  };

  requestAnimationFrame(MyUpdateLoop);

  // this function is called when the window is resized
  var MyResize = function ( )
  {
    var width = window.innerWidth;
    var height = window.innerHeight;
    renderer.setSize(width,height);
    camera.aspect = width/height;
    camera.updateProjectionMatrix();
    renderer.render(scene,camera);
  };

  // link the resize of the window to the update of the camera
  window.addEventListener( 'resize', MyResize);

  // ---------------------------- --- ---------------------------- //
  // ---------------------------- GUI ---------------------------- //
  // ---------------------------- --- ---------------------------- //

  const gui = new GUI();
  const myStruct =
  {
    pause: is_paused,
    max_dist: max_force_dist,
    min_dist: inflection_distance,
    for_fac: force_factor,
    dt: delta_time,
    p_scale: particles_scale,
    shader_toggle: shader_enabled,
    cell_size: cell_finder_size,
    palette: palette_num,
    col_count: colour_count,
    is_gridded: visualise_grid,
    trails: has_trails,
    trail_l: trail_length,
    vol: music_vol,
    part_cam: part_cam_enabled
  };

  let folderParameters = gui.addFolder("Parameters");

  folderParameters.add(myStruct, "pause").name("Pause").onChange(value => {
    is_paused = value;
    music_check();
  });
  folderParameters.add(myStruct, "max_dist", 2, 50, 1).name("Max Force Dist").onChange(value => {
    max_force_dist = value;
    grid_scale = Math.min(Math.max(Math.floor(simulation_radius.x / (2 * max_force_dist)), 3), 6);
  // adjust grid
  if (visualise_grid) { generate_grid();}});
  folderParameters.add(myStruct, "min_dist", 0.05, 0.8, 0.05).name("Min Force Dist").onChange(value => { inflection_distance = value; });
  folderParameters.add(myStruct, "for_fac", 1, 30, 1).name("Force Scale").onChange(value => { force_factor = value; });
  folderParameters.add(myStruct, "dt", 0.0001, 0.04, 0.0001).name("Sim Speed").onChange(value => { delta_time = value; friction_factor = Math.pow(0.5, delta_time / friction_half_life); });
  folderParameters.add(simulation_radius, "x", 5, 300, 5).name("Sim Size").onChange(value => {
    simulation_radius.x = value;
    simulation_radius.z = value;
    sim_cube.scale.x = value;
    sim_cube.scale.z = value;
    sim_cube.position.x = value / 2;
    sim_cube.position.z = value / 2;
    // update camera
    mid_point = new THREE.Vector3(simulation_radius.x / 2, simulation_radius.y / 2, simulation_radius.z / 2);
    controls.target = mid_point;
    
    // check for cam
    if (part_cam_enabled) { controls.target = particles[particle_cam_focus].position; }

    // adjust grid
    if (visualise_grid) { generate_grid(); }
  });
  folderParameters.add(simulation_radius, "y", 0, 300, 5).name("Sim Depth").onChange(value => {
    simulation_radius.y = value;
    sim_cube.scale.y = value;
    sim_cube.position.y = value / 2;
    mid_point = new THREE.Vector3(simulation_radius.x / 2, simulation_radius.y / 2, simulation_radius.z / 2);
    controls.target = mid_point;
    for (var i = 0; i < particle_count; i++) {
      particles[i].position.y = Math.random() * value;
    }

    // check for cam
    if (part_cam_enabled) { controls.target = particles[particle_cam_focus].position; }

    // adjust grid
    if (visualise_grid) { generate_grid(); }
  });
  folderParameters.add(myStruct, "p_scale", 0.1, 1.5, 0.1).name("Particle Size").onChange(value => {
    particles_scale = value;
    for (var i = 0; i < particle_count; i++) {
      particles[i].scale.x = particles_scale;
      particles[i].scale.y = particles_scale;
      particles[i].scale.z = particles_scale;
    }
  });
  folderParameters.add(myStruct, "col_count", 1, 6, 1).name("Colour Count").onChange(value => {
    const pause_state = is_paused;
    is_paused = true;

    // -- REDUCING COLOUR COUNT
    if (value < colour_count) {
      // Resize pColours
      while (pColours.length > value) {
        pColours.pop();
      }

      // Resize matrix
      while (matrix.length > value) {
        matrix.pop();
        matrix[matrix.length - 1].pop();
      }

      // Resize interaction parameters
      delete_interaction_parameters();
      populate_interaction_parameters();
    }
    // -- INCREASING COLOUR COUNT
    else {
      // Resize pColours
      while (pColours.length < value) {
        pColours.push(palettes[palette_num][pColours.length]);
      }

      // Resize matrix
      while (matrix.length < value) {
        const row = [];
        for (let i = 0; i < value; i++) {
          if (i < matrix.length) {
            matrix[i].push(new Rule(pColours[i], pColours[matrix.length], Math.random() * 2 - 1));
          }
          row.push(new Rule(pColours[matrix.length], pColours[i], Math.random() * 2 - 1));
        }
        matrix.push(row);
      }

      // Resize interaction parameters
      delete_interaction_parameters();
      populate_interaction_parameters();
    }
    
    // Updating particle colours
    for (var i = 0; i < particle_count; i++) {
      var c = Math.floor((i / particle_count) * pColours.length);
      particles[i].material.uniforms.pCol.value = pColours[c].colour;
      particles[i].userData.pColour = pColours[c].name;
      particles[i].userData.pColourNum = c;
    }

    // update cam
    //set_part_cam(part_cam_enabled);
    document.getElementById('particle_cam_label').style.color = pColours[particles[particle_cam_focus].userData.pColourNum].colour.getHexString();

    colour_count = value;
    is_paused = pause_state;

    music_check();
  });
  

  // Interaction parameters
  let interactionParameters = gui.addFolder("Interactions");
  function populate_interaction_parameters() {
    for (let c1 = 0; c1 < pColours.length; c1++) {
      for (let c2 = 0; c2 < pColours.length; c2++) {
        var rule = matrix[c1][c2];
        const para_name = pColours[c1].name + " X " + pColours[c2].name;
        interactionParameters.add(rule, "force", -1.0, 1.0, 0.1).name(para_name).onChange(value => { rule.force = value; });//.listen();
      }
    }
  }
  function delete_interaction_parameters() {
    while (interactionParameters.__controllers.length > 0) {
      interactionParameters.__controllers[interactionParameters.__controllers.length - 1].remove();
    }
  }

  populate_interaction_parameters();
  

  // Shader parameters
  let shaderParameters = gui.addFolder("Shaders");
  shaderParameters.add(simulation_mat, "wireframe").name("Sim Wireframe").onChange(value => { simulation_mat.wireframe = value; });
  // shaderParameters.add(myStruct, "is_gridded").name("Visualise Grid").onChange(value => {
  //   visualise_grid = value;
  //   if (visualise_grid) { generate_grid(); }
  //   else { delete_grid(); }
  // });
  shaderParameters.add(myStruct, "shader_toggle").name("Cell-Finder").onChange(value => {
    myStruct.part_cam = false;
    set_part_cam(false);
    gui.updateDisplay();

    set_cell_finder(value);
  });
  function set_cell_finder(value) {
    shader_enabled = value;
    for (var i = 0; i < particle_count; i++) {
      particles[i].material.uniforms.neighbour_count.value = 0.0;
    }
  }
  shaderParameters.add(myStruct, "cell_size", 50, 600, 50).name("Cell-Finder Size").onChange(value => { cell_finder_size = value; });
  shaderParameters.add(myStruct, "palette", 0, 7, 1).name("Colour Palette").onChange(value => {
    palette_num = value;
    //pColours = palettes[palette_num];
    for (let i = 0; i < colour_count; i++) {
      pColours[i] = palettes[palette_num][i];
    }
    for (var i = 0; i < particle_count; i++) {
      var c = Math.floor((i / particle_count) * pColours.length);
      particles[i].material.uniforms.pCol.value = pColours[c].colour;
      particles[i].userData.pColour = pColours[c].name;
      particles[i].userData.pColourNum = c;

      particles[i].userData.trail.material.uniforms.headColor.value = new THREE.Vector4(pColours[c].colour.r, pColours[c].colour.g, pColours[c].colour.b, 1.0);
      particles[i].userData.trail.material.uniforms.tailColor.value = new THREE.Vector4(pColours[c].colour.r, pColours[c].colour.g, pColours[c].colour.b, 0.1);
    }
    
    renderer.setClearColor(backgrounds[palette_num]);

    delete_interaction_parameters();
    populate_interaction_parameters();

    // update cam
    //set_part_cam(part_cam_enabled);
    document.getElementById('particle_cam_label').style.color = pColours[particles[particle_cam_focus].userData.pColourNum].colour.getHexString();

    // adjust grid
    if (visualise_grid) { generate_grid(); }
    
    gui.updateDisplay();
  });
  shaderParameters.add(myStruct, "trails").name("Trails").onChange(value => {
    if (has_trails && value == false) {
      for (var i = 0; i < particle_count; i++) {
        particles[i].userData.trail.deactivate();
      }
    }
    else if (!has_trails && value == true) {
      for (var i = 0; i < particle_count; i++) {
        particles[i].userData.trail.activate();
      }
    }
    
    has_trails = value;
  });
  shaderParameters.add(myStruct, "part_cam").name("Particle Cam").onChange(value => {
    myStruct.shader_toggle = false;
    set_cell_finder(false);
    gui.updateDisplay();

    set_part_cam(value);
  });
  function set_part_cam(value) {
    if (value) {
      // choose random particle
      particle_cam_focus = Math.floor(Math.random() * (particle_count - 1));

      // pick name based on colour
      const p_colour = particles[particle_cam_focus].userData.pColourNum;
      const rand = 0; //Math.round(Math.random() * 9);
      var name = "";

      switch (p_colour) {
        case 0:
          name = c0_names[Math.round(Math.random() * (c0_names.length - 1))];
          break
        case 1:
          name = c1_names[Math.round(Math.random() * (c1_names.length - 1))];
          break
        case 2:
          name = c2_names[Math.round(Math.random() * (c2_names.length - 1))];
          break
        case 3:
          name = c3_names[Math.round(Math.random() * (c3_names.length - 1))];
          break
        case 4: 
          name = c4_names[Math.round(Math.random() * (c4_names.length - 1))];
          break
        case 5:
          name = c5_names[Math.round(Math.random() * (c5_names.length - 1))];
          break
      }

      document.getElementById('particle_cam_label').textContent = "" + name + " CAM";
      document.getElementById('particle_cam_label').style.color = pColours[p_colour].colour.getHexString();

      // phase out colours a bit
      for (var i = 0; i < particle_count; i++) {
        if (i == particle_cam_focus) { particles[i].material.uniforms.neighbour_count.value = 0.0; continue; }
        particles[i].material.uniforms.neighbour_count.value = 0.8;
      }

      // fix camera to follow
      controls.target = particles[particle_cam_focus].position;
      
    }
    else {
      // clear name
      document.getElementById('particle_cam_label').textContent = " ";

      // bring back colours
      for (var i = 0; i < particle_count; i++) {
        particles[i].material.uniforms.neighbour_count.value = 0.0;
      }

      // reset camera
      mid_point = new THREE.Vector3(simulation_radius.x / 2, simulation_radius.y / 2, simulation_radius.z / 2);
      controls.target = mid_point;
    }

    part_cam_enabled = value;
  }
  // shaderParameters.add(myStruct, "trail_l", 5, 100, 5).name("Trail Length").onChange(value => {
  //   trail_length = value;
  //   for (var i = 0; i < particle_count; i++) {
  //     particles[i].userData.trail.material.uniforms.maxTrailLength.value = trail_length;
  //     particles[i].userData.trail.reset();
  //   }
  // });


  

  // ---------------------------- ------- ---------------------------- //
  // ---------------------------- PRESETS ---------------------------- //
  // ---------------------------- ------- ---------------------------- //

  // Preset Buttons
  let presetButtons = gui.addFolder("Presets");
  // randomise particle positions
  var randomisePositions = { RandomisePositions:function(){
    for (let i = 0; i < particle_count; i++) {
      particles[i].position.x = Math.random() * simulation_radius.x;
      particles[i].position.y = Math.random() * simulation_radius.y;
      particles[i].position.z = Math.random() * simulation_radius.z;
    }
  }};
  // RandomiseAll randomises all interaction values
  var randomiseAllInteractions = { RandomiseAllInteractions:function(){
    for (let i = 0; i < pColours.length; i++) {
      for (let j = 0; j < pColours.length; j++) {
        matrix[i][j].force = Math.random() * 2 - 1;
      }
    }
    gui.updateDisplay();
  }};
  // Randomise randomises all interaction values EXCEPT same colour interactions that are kept >= 0
  var randomiseInteractions = { RandomiseInteractions:function(){
    for (let i = 0; i < pColours.length; i++) {
      for (let j = 0; j < pColours.length; j++) {
        if (i == j) {
          matrix[i][j].force = Math.random();
        }
        else {
          matrix[i][j].force = Math.random() * 2 - 1;
        }
        
      }
    }
    gui.updateDisplay();
  }};
  // Blank resets all interaction values to 0
  var blankInteractionPreset = { BlankInteractionsPreset:function(){
    for (let i = 0; i < pColours.length; i++) {
      for (let j = 0; j < pColours.length; j++) {
        matrix[i][j].force = 0;
      }
    }
    gui.updateDisplay();
  }};

  presetButtons.add(randomisePositions,'RandomisePositions').name("Randomise Positions");
  presetButtons.add(blankInteractionPreset,'BlankInteractionsPreset').name("Blank Interactions");
  presetButtons.add(randomiseAllInteractions,'RandomiseAllInteractions').name("Randomise All Interactions");
  presetButtons.add(randomiseInteractions,'RandomiseInteractions').name("Randomise Unlike Interactions");

  // Music Controls
  let audioParameters = gui.addFolder("Audio");
  audioParameters.add(myStruct, "vol", 0.0, 1.0, 0.1).name("Music Volume").onChange(value => {
    music_vol = value;
    musicBot.setVolume(music_vol);
  });
  

    </script>
  </body>
</html>
